#include "CppUnitTest.h"
#include "../EllipticCurvesLibrary/EllipticCurve.h"
#include "../EllipticCurvesLibrary/EllipticCurve.cpp"
#include <string>

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace EllipticCurvesLibrary;

namespace Microsoft
{
	namespace VisualStudio
	{
		namespace CppUnitTestFramework
		{
			template<>
			static std::wstring ToString<Point>(const Point& point) {
				std::string coordX = point.getX().get_str();
				std::string coordY = point.getY().get_str();
				std::string output = "(" + coordX + ";" + coordY + ")";
				return std::wstring(output.begin(), output.end());
			}

			template<>
			static std::wstring ToString<std::vector<int>>(const std::vector<int>& v) {
				std::string output;
				for (auto i = v.begin(); i != v.end(); ++i) {
					switch (*i)
					{
					case -1:
						output += "-1, ";
						break;
					case 0:
						output += "0, ";
						break;
					case 1:
						output += "1, ";
						break;
					default:
						break;
					}
				}
				return std::wstring(output.begin(), output.end());
			}
		}
	}
}

namespace EllipticCurvesLibraryTests
{
	TEST_CLASS(EllipticCurvesLibraryTests)
	{
		mpz_class p;
		mpz_class a;
		mpz_class b;
		mpz_class x;
		mpz_class y;
		mpz_class expectedY;
		mpz_class x2;
		mpz_class y2;
		mpz_class expectedX2;
		mpz_class expectedY2;
		mpz_class n;

		mpz_class expectedX3;
		mpz_class expectedY3;

		std::string sForP = "499557256977219506380281345868505850806536870536066181139024969386512032771568813350165621784290905066210190413592751738596447503025705949107751116442344223236577235536504773278112648226610301283034800322975737256256519954201734040414098454787413957718966891611091832936397579180823123655431204786287";
		std::string sForA = "183193895025926354887777188414059074391157248724253484773456040004898586000484841059282733653978582849851809185152174737283705761769893905357243393402077471497652800605389770194116986380665712135613735181279836537078391184105496165710504284294408242616721546883325327552374571276620";
		std::string sForB = "3483284932984983278978952359329859275327985983258932985983298598888888883333333333333723219379279831239279398217873848834213218327381283281832183646846821192372179217379129372912371232132145993747937497934737479397479793794793747939439479216958907380084384834721832813829198184979457579849";
		std::string sForX = "88188005047532949155875992505255072994690697327668174332462138141283350630175068291724901451301764833496536843328026325185792291283818846317860566467086399895976005517133949538598528308328534528447125977161849016003122066251907162684191796888925879419306955879726458403529445120986222642699819982942";
		std::string sForY = "462105689058163424722718252306611290527948869271327401816842844316912417906967429933037480906119741918910568326936082860653817089543896919531096176778294621419568478956033066218611414435411029378551644319167648452883355363927022908904570107488640256135648340507591289204258634613220411222745504506793";
		std::string sForExpectedY = "37451567919056081657563093561894560278588001264738779322182125069599614864601383417128140878171163147299622086656668877942630413481809029576654939664049601817008756580471707059501233791199271904483156003808088803373164590274711131509528347298773701583318551103500543732138944567602712432685700279494";
		std::string sForX2 = "443823106834184572974335612766737727805865039533016378730040223971976246232500046540799037482357214213664711040992191268031586863925925233517889474491743700475246861480888261675295100675705524424448132397411753978465614295629812468784555919489599730944167236492156529989074816109773030167525948021479";
		std::string sForY2 = "271771072714352653476765783523690397038737025410138688662116656388517519034092588461020355594508370495370757529486027370735210469360679431858312828749725853702592359457050064743143123022785331393368388557167551760323951012462109441533813557518715114784475052094431724990654185490517481240515528392478";
		std::string sForExpectedX2 = "151261762521993299895989050065841856671740722733610367449596512590349752102322299143525705183697370277501115058583518697573338439053067291268239430872924696121771005134677570078283194897983366533543593758906751850749597891889076745199077354651169138183715682497013326907311670677661368790304676693958";
		std::string sForExpectedY2 = "449270439817072355203404998991085992097386160799718908087145306071586032351385080177484694944348322657951772844229419472269571641425299501175207775199067511407931065842526526430019630785788463866513308206852209928779668458101823188082123883318424782696529043119946214508861354655380473566638514258334";
		std::string sForN = "9380483480138941803802198128301280312830912840798794916401731237007947217498123";
		std::string sForExpectedX3 = "269757512645736357103655613842897326653044363016652832780107980520298829688570128091257065388096788844850980055660014748261572203019847193748827537224164408338114820109283228890345054574761852442377111303336523680099801886132407804065860852928368052814227382261254978643104810221293716191042033725326";
		std::string sForExpectedY3 = "179822541384563837492968402800303026388905368711589528584867413731189096743807249862606071484763401421352570858830483423995841457921886564916892108249650138327250329237734053295322113839905079778876239628995872793778717514667960277753654029959994780307709776840582418456729226808176876173035388767939";


	public:
		EllipticCurvesLibraryTests() {
			mpz_set_str(p.get_mpz_t(), sForP.c_str(), 10);
			mpz_set_str(a.get_mpz_t(), sForA.c_str(), 10);
			mpz_set_str(b.get_mpz_t(), sForB.c_str(), 10);

			mpz_set_str(x.get_mpz_t(), sForX.c_str(), 10);
			mpz_set_str(y.get_mpz_t(), sForY.c_str(), 10);
			mpz_set_str(expectedY.get_mpz_t(), sForExpectedY.c_str(), 10);

			mpz_set_str(x2.get_mpz_t(), sForX2.c_str(), 10);
			mpz_set_str(y2.get_mpz_t(), sForY2.c_str(), 10);
			mpz_set_str(expectedX2.get_mpz_t(), sForExpectedX2.c_str(), 10);
			mpz_set_str(expectedY2.get_mpz_t(), sForExpectedY2.c_str(), 10);

			mpz_set_str(n.get_mpz_t(), sForN.c_str(), 10);
			mpz_set_str(expectedX3.get_mpz_t(), sForExpectedX3.c_str(), 10);
			mpz_set_str(expectedY3.get_mpz_t(), sForExpectedY3.c_str(), 10);
			
		}
		TEST_METHOD(TestReversePoint)
		{
			EllipticCurve E(a, b, p);
			Point P(x, y, 0);
			Point actual = E.reversePoint(P);
			Point expected(x, expectedY, 0);
			Assert::AreEqual(actual, expected);
		}

		TEST_METHOD(TestSumPoints)
		{
			EllipticCurve E(a, b, p);
			Point P(x, y, 0);
			Point Q(x2, y2, 0);
			Point actual = E.sumTwoPoints(Q, P);
			Point expected(expectedX2, expectedY2, 0);
			Assert::AreEqual(expected, actual);
		}

		TEST_METHOD(TestDoubleAndAdd)
		{
			EllipticCurve E(a, b, p);
			Point P(x, y, 0);
			Point actual = E.doubleAndAdd(P, n);
			Point expected(expectedX3, expectedY3, 0);
			Assert::AreEqual(expected, actual);
		}

		TEST_METHOD(testTernaryDecomposition)
		{
			mpz_class test = 57188;
			std::vector<int> expected = { 1, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 1, 0, 0 };
			std::vector<int> actual = ternaryDecomposition(test);
			Assert::AreEqual(expected, actual);
		}

		TEST_METHOD(testTernaryMehtod)
		{
			EllipticCurve E(a, b, p);
			Point P(x, y, 0);
			Point actual = E.ternaryMethod(P, n);
			Point expected(expectedX3, expectedY3, 0);
			Assert::AreEqual(expected, actual);
		}
		TEST_METHOD(TestEEA)
		{
			mpz_class a(2);
			mpz_class p(107);
			std::vector<mpz_class> res = EEA(a, p);
			mpz_class actual = res[0];
			mpz_class expected(1);
			Assert::AreEqual(expected.get_str(10), actual.get_str(10));
		}

		TEST_METHOD(testCurveOrderLess229)
		{
			EllipticCurve E(13, 32, 67);
			mpz_class expected = 56;
			mpz_class actual = E.curveOrder();
			Assert::AreEqual(expected.get_str(10), actual.get_str(10));
		}

		TEST_METHOD(testCurveOrderMore229)
		{
			EllipticCurve E(13, 32, 3035538503);
			mpz_class expected = 3035599362;
			mpz_class actual = E.curveOrder();
			Assert::AreEqual(expected.get_str(10), actual.get_str(10));
		}

		TEST_METHOD(testSearchPoint)
		{
			EllipticCurve E(a, b, p);
			std::string expected = "yes", actual = "yes";
			Point P = E.searchPoint();
			if (!E.checkPoint(P))
			{
				actual = "no";
			}
			Assert::AreEqual(expected, actual);
		}
	};
}
